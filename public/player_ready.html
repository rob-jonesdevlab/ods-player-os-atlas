<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>ODS Player</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@700&display=swap"
        rel="stylesheet" />
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            background: #000 !important;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Inter', -apple-system, sans-serif;
        }

        body {
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        body.ready {
            opacity: 1;
        }

        /* ─── Content Display ─── */
        .player-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slide.active {
            opacity: 1;
            z-index: 2;
        }

        .slide.outgoing {
            opacity: 0;
            z-index: 1;
        }

        .slide img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        .slide video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        /* ─── Waiting for Content State ─── */
        .waiting-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #0a0a0a;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .waiting-state.ready {
            opacity: 1;
        }

        .waiting-state.hidden {
            display: none;
        }

        .waiting-container {
            text-align: center;
            max-width: 600px;
            padding: 40px;
            margin-top: 10vh;
        }

        .logo {
            width: 160px;
            height: 160px;
            margin: 0 auto 40px;
            border-radius: 28px;
            animation: logo-glow 3s ease-in-out infinite;
        }

        .logo img {
            width: 100%;
            height: 100%;
            border-radius: 28px;
        }

        @keyframes logo-glow {

            0%,
            100% {
                filter: drop-shadow(0 8px 32px rgba(245, 132, 42, 0.3));
            }

            50% {
                filter: drop-shadow(0 8px 48px rgba(245, 132, 42, 0.5));
            }
        }

        .waiting-title {
            font-size: 3.5rem;
            font-weight: 600;
            margin-bottom: 12px;
            background: linear-gradient(135deg, #fff, #ccc);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .waiting-subtitle {
            color: #888;
            font-size: 1.7rem;
            margin-bottom: 48px;
        }

        .info-table {
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 16px 0;
            border-bottom: 1px solid #1a1a1a;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #666;
            font-size: 1.3rem;
        }

        .info-value {
            color: #ddd;
            font-size: 1.4rem;
            font-weight: 500;
        }

        .info-value.connected {
            color: #22c55e;
        }

        .info-value.disconnected {
            color: #ef4444;
        }

        .info-value.uppercase {
            text-transform: uppercase;
        }

        /* ─── Status Pill (dark-themed, bottom-center) ─── */
        .status-footer {
            position: absolute;
            width: 100%;
            display: flex;
            justify-content: center;
            z-index: 10;
            top: 90%;
            transform: translateY(-50%);
        }

        .glass-pill {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.875rem 1.75rem;
            border-radius: 9999px;
        }

        .dot-container {
            position: relative;
            width: 0.875rem;
            height: 0.875rem;
        }

        .dot-ping {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 9999px;
            background: #fbbf24;
            opacity: 0.75;
            animation: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;
        }

        .dot-solid {
            position: relative;
            width: 0.875rem;
            height: 0.875rem;
            border-radius: 9999px;
            background: #f59e0b;
        }

        .pill-text {
            color: rgba(255, 255, 255, 0.7);
            font-weight: 600;
            font-size: 1.5rem;
        }

        @keyframes ping {

            75%,
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        @keyframes pulse-dot {

            0%,
            100% {
                opacity: 0.3;
            }

            50% {
                opacity: 1;
            }
        }

        /* ─── Progress Bar (thin, top edge) ─── */
        .slide-progress {
            position: fixed;
            top: 0;
            left: 0;
            height: 3px;
            background: rgba(59, 130, 246, 0.7);
            z-index: 50;
            transition: width linear;
            border-radius: 0 2px 2px 0;
        }

        /* ─── Keyboard lockdown ─── */
        body.locked * {
            user-select: none !important;
        }

        /* ─── Offline Border Overlay ─── */
        .offline-border {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 99;
            box-sizing: border-box;
            border: 0px solid transparent;
            transition: border-color 0.6s ease;
            will-change: border-color, border-width, box-shadow, background-position;
        }

        .offline-border.active {
            border-width: 0.450px;
        }

        /* ─── Stage 4: Marching Ants (Templates 0, 4) ─── */
        .offline-border.anim-ants {
            border: 0.450px solid transparent;
            background-image:
                linear-gradient(90deg, var(--ob-stage4) 50%, transparent 50%),
                linear-gradient(90deg, var(--ob-stage4) 50%, transparent 50%),
                linear-gradient(0deg, var(--ob-stage4) 50%, transparent 50%),
                linear-gradient(0deg, var(--ob-stage4) 50%, transparent 50%);
            background-repeat: repeat-x, repeat-x, repeat-y, repeat-y;
            background-size: 20px 0.450px, 20px 0.450px, 0.450px 20px, 0.450px 20px;
            background-position: 0 0, 100% 100%, 0 100%, 100% 0;
            animation: marching-ants 1s linear infinite;
        }

        @keyframes marching-ants {
            0% {
                background-position: 0 0, 100% 100%, 0 100%, 100% 0;
            }

            100% {
                background-position: 20px 0, -20px 100%, 0 -20px, 100% 20px;
            }
        }

        /* ─── Stage 4: Breathing Glow (Template 2) ─── */
        .offline-border.anim-glow {
            border: 0.450px solid var(--ob-stage4);
            animation: breathing-glow 2s ease-in-out infinite;
        }

        @keyframes breathing-glow {

            0%,
            100% {
                box-shadow: inset 0 0 10px var(--ob-stage4-glow), 0 0 10px var(--ob-stage4-glow);
            }

            50% {
                box-shadow: inset 0 0 25px var(--ob-stage4-glow), 0 0 35px var(--ob-stage4-glow);
            }
        }

        /* ─── Stage 4: Heartbeat Pulse (Template 5) ─── */
        .offline-border.anim-heartbeat {
            border-color: var(--ob-stage4);
            animation: heartbeat 1.5s ease-in-out infinite;
        }

        @keyframes heartbeat {

            0%,
            100% {
                border-width: 0.450px;
            }

            50% {
                border-width: 0.90px;
            }
        }

        /* ─── Stage 4: Conic Gradient Rotation (Template 3) ─── */
        .offline-border.anim-conic {
            border: 0.450px solid transparent;
            border-image: conic-gradient(var(--ob-stage4), var(--ob-stage3), var(--ob-stage4)) 1;
            animation: conic-rotation 2s linear infinite;
        }

        @keyframes conic-rotation {
            0% {
                filter: hue-rotate(0deg);
            }

            100% {
                filter: hue-rotate(360deg);
            }
        }

        /* ─── Stage 4: Synchronous Blink (Template 1) ─── */
        .offline-border.anim-blink {
            animation: sync-blink 2s steps(1) infinite;
        }

        @keyframes sync-blink {

            0%,
            49.9% {
                border-color: #000000;
            }

            50%,
            100% {
                border-color: #ffffff;
            }
        }

        /* ─── Debug Overlay ─── */
        .offline-debug {
            position: fixed;
            top: 8px;
            left: 8px;
            padding: 6px 12px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            z-index: 200;
            pointer-events: none;
            display: none;
        }

        .offline-debug.visible {
            display: block;
        }
    </style>
</head>

<body>
    <!-- Content Canvas -->
    <div class="player-canvas" id="playerCanvas"></div>

    <!-- Waiting for Content -->
    <div class="waiting-state" id="waitingState">
        <div class="waiting-container">
            <div class="logo">
                <img src="/resources/ods-player-logo.png" alt="ODS" />
            </div>
            <div class="waiting-title">Player Ready</div>
            <p class="waiting-subtitle">Otter Digital Signage</p>

            <div class="info-table">
                <div class="info-row">
                    <span class="info-label">Account</span>
                    <span class="info-value" id="infoAccount">Loading...</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Device</span>
                    <span class="info-value" id="infoDevice">Loading...</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Hostname</span>
                    <span class="info-value uppercase" id="infoHostname">Loading...</span>
                </div>
                <div class="info-row">
                    <span class="info-label">IP Address</span>
                    <span class="info-value" id="infoIp">Loading...</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Network</span>
                    <span class="info-value" id="infoNetwork">Checking...</span>
                </div>
                <div class="info-row">
                    <span class="info-label">ODS Cloud</span>
                    <span class="info-value" id="infoCloud">Connecting...</span>
                </div>
            </div>

        </div>
    </div>

    <!-- Status Pill -->
    <footer class="status-footer">
        <div class="glass-pill pill" id="statusPill">
            <span class="dot-container">
                <span class="dot-ping"></span>
                <span class="dot-solid"></span>
            </span>
            <span class="pill-text" id="pillText">Waiting for content...</span>
        </div>
    </footer>

    <!-- Slide Progress Bar -->
    <div class="slide-progress" id="slideProgress"></div>

    <!-- Offline Border Overlay -->
    <div class="offline-border" id="offlineBorder"></div>

    <!-- Debug Overlay -->
    <div class="offline-debug" id="offlineDebug"></div>


    <script>
        // ========================================
        // ODS PLAYER — Content Renderer
        // ========================================
        const API_URL = 'https://api.ods-cloud.com';
        const CONFIG_POLL_INTERVAL = 30 * 1000;     // Check for config changes every 30s
        const HEARTBEAT_INTERVAL = 60 * 1000;       // Heartbeat every 60s
        const RECONNECT_DELAY = 5000;

        let playerId = localStorage.getItem('ods_player_id');
        let deviceUuid = localStorage.getItem('ods_device_uuid');
        let cpuSerial = localStorage.getItem('ods_cpu_serial');
        let socket = null;
        let currentConfig = null;
        let currentConfigHash = null;
        let slideTimer = null;
        let progressTimer = null;
        let currentSlideIndex = 0;
        let assets = [];
        let hasConnected = false; // Track if WS has ever connected

        // ─── Status Pill Updates ───
        function updatePill(dotColor, text, pulse = false) {
            const pill = document.getElementById('statusPill');
            if (!pill) return;
            pill.innerHTML = `
                <span class="dot-solid" style="background: ${dotColor}; ${pulse ? 'animation: pulse-dot 1.5s infinite;' : ''}"></span>
                <span class="pill-text">${text}</span>
            `;
        }
        function setStatus(state, label) { /* legacy no-op */ }

        // ─── Redirect if not paired ───
        if (!playerId && !deviceUuid) {
            window.location.href = '/player_link.html';
        }

        // ─── WebSocket Connection ───
        function connectWebSocket() {
            socket = io(API_URL, {
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionDelay: RECONNECT_DELAY,
                reconnectionAttempts: Infinity
            });

            socket.on('connect', () => {
                console.log('[WS] Connected');
                hasConnected = true;
                updatePill('#14b8a6', 'Connected to ODS Cloud');
                clearOfflineBorder();
                // Update cloud status in info table
                const cloudEl = document.getElementById('infoCloud');
                if (cloudEl) { cloudEl.textContent = 'Connected'; cloudEl.className = 'info-value connected'; }

                // Register this player
                socket.emit('register', {
                    cpu_serial: cpuSerial,
                    name: localStorage.getItem('ods_device_name') || 'ODS Player',
                    device_uuid: deviceUuid
                });
            });

            socket.on('registered', (player) => {
                console.log('[WS] Registered:', player.id);
                if (!playerId) {
                    playerId = player.id;
                    localStorage.setItem('ods_player_id', playerId);
                }
            });

            // Real-time playlist deployment
            socket.on('deploy_playlist', async (data) => {
                console.log('[WS] Playlist deployed:', data);
                updatePill('#14b8a6', 'Content received...');
                await fetchConfig();
            });

            // Pairing success — reload config
            socket.on('pairing:success', async (data) => {
                if (data.device_uuid === deviceUuid) {
                    console.log('[WS] Pairing confirmed');
                    await fetchConfig();
                }
            });

            socket.on('disconnect', () => {
                console.log('[WS] Disconnected');
                updatePill('#ef4444', 'Disconnected');
                startOfflineBorder();
                const cloudEl = document.getElementById('infoCloud');
                if (cloudEl) { cloudEl.textContent = 'Reconnecting...'; cloudEl.className = 'info-value disconnected'; }
            });

            socket.on('connect_error', (err) => {
                console.error('[WS] Connection error:', err.message);
                const label = hasConnected ? 'Reconnecting...' : 'Connecting...';
                updatePill('#f97316', label, true);
                startOfflineBorder();
                const cloudEl = document.getElementById('infoCloud');
                if (cloudEl) { cloudEl.textContent = label; cloudEl.className = 'info-value'; }
            });
        }

        // ─── Heartbeat ───
        setInterval(() => {
            if (socket?.connected) {
                socket.emit('heartbeat', { player_id: playerId });
            }
        }, HEARTBEAT_INTERVAL);

        // ─── Config Fetch ───
        async function fetchConfig() {
            try {
                if (!deviceUuid) return;

                // First: lightweight hash check
                if (currentConfigHash) {
                    try {
                        const hashResp = await fetch(`${API_URL}/api/device/config/hash/${deviceUuid}`);
                        if (hashResp.ok) {
                            const hashData = await hashResp.json();
                            if (hashData.config_hash === currentConfigHash) {
                                console.log('[Config] No changes');
                                return; // Config unchanged
                            }
                        }
                    } catch (e) {
                        console.warn('[Config] Hash check failed, fetching full config');
                    }
                }

                // Full config fetch
                updatePill('#3b82f6', 'Updating configuration...');
                const resp = await fetch(`${API_URL}/api/device/config/${deviceUuid}`);
                if (!resp.ok) {
                    if (resp.status === 403) {
                        console.log('[Config] Device not paired yet');
                        updatePill('#f59e0b', 'Waiting for content...', true);
                        showWaiting();
                        return;
                    }
                    console.error('[Config] Fetch failed:', resp.status);
                    updatePill('#ef4444', 'Update failed!');
                    return;
                }

                const config = await resp.json();
                currentConfig = config;
                currentConfigHash = config.config_hash;
                updatePill('#a855f7', 'Update complete...', true);

                // Store player_id from config for WebSocket
                if (config.player_id && !playerId) {
                    playerId = config.player_id;
                    localStorage.setItem('ods_player_id', playerId);
                }

                console.log('[Config] Loaded:', {
                    playlist: config.playlist?.name,
                    assets: config.playlist?.assets?.length || 0
                });

                if (config.playlist && config.playlist.assets?.length > 0) {
                    updatePill('#10b981', 'Ready');
                    await loadPlaylist(config.playlist);
                } else {
                    updatePill('#f59e0b', 'Waiting for content...', true);
                    showWaiting();
                }

                // Apply offline border template from org config
                if (config.offline_border) {
                    const tpl = config.offline_border.template;
                    if (typeof tpl === 'number' && tpl >= 0 && tpl < OFFLINE_TEMPLATES.length) {
                        applyTemplate(tpl);
                    }
                    // Future: custom_colors override
                    if (config.offline_border.custom_colors && config.offline_border.custom_colors.length === 4) {
                        const cc = config.offline_border.custom_colors;
                        const root = document.documentElement.style;
                        root.setProperty('--ob-stage1', cc[0]);
                        root.setProperty('--ob-stage2', cc[1]);
                        root.setProperty('--ob-stage3', cc[2]);
                        root.setProperty('--ob-stage4', cc[3]);
                    }
                }

                // Report sync status
                if (socket?.connected) {
                    socket.emit('sync_status', {
                        status: 'synced',
                        config_hash: currentConfigHash,
                        downloaded: config.playlist?.assets?.length || 0
                    });
                }

            } catch (error) {
                console.error('[Config] Error:', error);
                setStatus('offline', 'error');
            }
        }

        // ─── Playlist Rendering ───
        function showWaiting() {
            const ws = document.getElementById('waitingState');
            ws.classList.remove('hidden');
            ws.style.display = 'flex';
            // Trigger opacity transition
            requestAnimationFrame(() => ws.classList.add('ready'));
            document.getElementById('playerCanvas').innerHTML = '';
            document.getElementById('slideProgress').style.width = '0';
            clearTimeout(slideTimer);
            clearInterval(progressTimer);
            assets = [];
            currentSlideIndex = 0;
        }

        async function loadPlaylist(playlist) {
            // Hide waiting state
            document.getElementById('waitingState').classList.add('hidden');

            assets = playlist.assets.sort((a, b) => a.order - b.order);
            currentSlideIndex = 0;

            if (assets.length === 0) {
                showWaiting();
                return;
            }

            // Pre-create slide elements
            const canvas = document.getElementById('playerCanvas');
            canvas.innerHTML = '';

            assets.forEach((asset, i) => {
                const slide = document.createElement('div');
                slide.className = 'slide' + (i === 0 ? ' active' : '');
                slide.id = `slide-${i}`;

                if (asset.type === 'video') {
                    const video = document.createElement('video');
                    video.src = `${API_URL}${asset.url}`;
                    video.autoplay = (i === 0);
                    video.muted = true;
                    video.loop = false;
                    video.playsInline = true;
                    video.preload = 'auto';
                    video.addEventListener('ended', () => nextSlide());
                    video.addEventListener('error', (e) => {
                        console.error(`[Video] Error loading asset ${asset.id}:`, e);
                        nextSlide();
                    });
                    slide.appendChild(video);
                } else {
                    // Image (default)
                    const img = document.createElement('img');
                    img.src = `${API_URL}${asset.url}`;
                    img.alt = asset.filename || '';
                    img.loading = (i < 2) ? 'eager' : 'lazy';
                    img.addEventListener('error', (e) => {
                        console.error(`[Image] Error loading asset ${asset.id}:`, e);
                    });
                    slide.appendChild(img);
                }

                canvas.appendChild(slide);
            });

            // Start slideshow
            startSlideTimer();
        }

        function startSlideTimer() {
            clearTimeout(slideTimer);
            clearInterval(progressTimer);

            const asset = assets[currentSlideIndex];
            if (!asset) return;

            const slide = document.getElementById(`slide-${currentSlideIndex}`);
            const video = slide?.querySelector('video');

            // For videos, let the 'ended' event handle transition
            if (asset.type === 'video' && video) {
                video.currentTime = 0;
                video.play().catch(e => console.warn('[Video] Autoplay blocked:', e));
                // Progress bar for video
                const updateVideoProgress = () => {
                    if (video.duration) {
                        const pct = (video.currentTime / video.duration) * 100;
                        document.getElementById('slideProgress').style.width = `${pct}%`;
                    }
                    if (!video.ended) requestAnimationFrame(updateVideoProgress);
                };
                requestAnimationFrame(updateVideoProgress);
                return;
            }

            // For images, use duration timer
            const duration = (asset.duration || 10) * 1000;
            const progressBar = document.getElementById('slideProgress');
            progressBar.style.transition = 'none';
            progressBar.style.width = '0%';

            // Trigger reflow then animate
            requestAnimationFrame(() => {
                progressBar.style.transition = `width ${duration}ms linear`;
                progressBar.style.width = '100%';
            });

            slideTimer = setTimeout(() => nextSlide(), duration);
        }

        function nextSlide() {
            const prevIndex = currentSlideIndex;
            currentSlideIndex = (currentSlideIndex + 1) % assets.length;

            // Pause previous video
            const prevSlide = document.getElementById(`slide-${prevIndex}`);
            const prevVideo = prevSlide?.querySelector('video');
            if (prevVideo) prevVideo.pause();

            // Transition
            prevSlide?.classList.remove('active');
            prevSlide?.classList.add('outgoing');

            const nextSlideEl = document.getElementById(`slide-${currentSlideIndex}`);
            nextSlideEl?.classList.add('active');

            // Clean outgoing after transition
            setTimeout(() => {
                prevSlide?.classList.remove('outgoing');
            }, 1200);

            startSlideTimer();
        }

        // ─── Config Polling ───
        setInterval(() => fetchConfig(), CONFIG_POLL_INTERVAL);

        // ========================================
        // OFFLINE BORDER SYSTEM
        // ========================================

        const OFFLINE_TEMPLATES = [
            {
                name: 'Standard Logic',
                stages: ['#FFFF00', '#FFA500', '#FF0000', '#FF0000'],
                animation: 'ants'
            },
            {
                name: 'Minimal & Neutral',
                stages: ['#F2D2BD', '#CC7722', '#361010', '#000000'],
                animation: 'blink'
            },
            {
                name: 'Tokyo Night',
                stages: ['#24283b', '#e0af68', '#f7768e', '#f7768e'],
                animation: 'glow',
                glowColor: 'rgba(247, 118, 142, 0.8)'
            },
            {
                name: 'Catppuccin',
                stages: ['#f5e0dc', '#fab387', '#eba0ac', '#eba0ac'],
                animation: 'conic'
            },
            {
                name: 'Monokai Pro',
                stages: ['#a9dc76', '#fc9867', '#ff6188', '#ff6188'],
                animation: 'ants'
            },
            {
                name: 'Natural & Calm',
                stages: ['#87a980', '#d2b48c', '#e2725b', '#e2725b'],
                animation: 'heartbeat'
            }
        ];

        let offlineStart = null;
        let offlineBorderTimer = null;
        let activeTemplateIndex = 0;
        let debugMode = false;
        let debugTimeMultiplier = 1;  // 1 = real-time, 60 = 1min per second

        function applyTemplate(index) {
            const t = OFFLINE_TEMPLATES[index];
            if (!t) return;
            activeTemplateIndex = index;
            const root = document.documentElement.style;
            root.setProperty('--ob-stage1', t.stages[0]);
            root.setProperty('--ob-stage2', t.stages[1]);
            root.setProperty('--ob-stage3', t.stages[2]);
            root.setProperty('--ob-stage4', t.stages[3]);
            root.setProperty('--ob-stage4-glow', t.glowColor || t.stages[3]);
        }

        function getOfflineMinutes() {
            if (!offlineStart) return 0;
            return ((Date.now() - offlineStart) / 60000) * debugTimeMultiplier;
        }

        function getStage(minutes) {
            if (minutes < 30) return 1;
            if (minutes < 60) return 2;
            if (minutes < 120) return 3;
            return 4;
        }

        function updateOfflineBorder() {
            if (!offlineStart) return;
            const minutes = getOfflineMinutes();
            const stage = getStage(minutes);
            const t = OFFLINE_TEMPLATES[activeTemplateIndex];
            const border = document.getElementById('offlineBorder');

            // Clear all animation classes
            border.classList.remove('anim-ants', 'anim-glow', 'anim-heartbeat', 'anim-conic', 'anim-blink');

            if (stage < 4) {
                // Stages 1-3: solid color
                border.className = 'offline-border active';
                border.style.borderColor = t.stages[stage - 1];
                border.style.animation = '';
                border.style.backgroundImage = '';
                border.style.boxShadow = '';
            } else {
                // Stage 4: animated
                border.className = 'offline-border active anim-' + t.animation;
                border.style.borderColor = '';
            }

            // Debug overlay
            if (debugMode) {
                const dbg = document.getElementById('offlineDebug');
                dbg.classList.add('visible');
                dbg.textContent = `T${activeTemplateIndex}: ${t.name} | Stage ${stage} | ${Math.floor(minutes)}m offline | ${debugTimeMultiplier}×`;
            }
        }

        function startOfflineBorder() {
            if (offlineStart) return;  // Already tracking
            offlineStart = Date.now();
            applyTemplate(activeTemplateIndex);
            updateOfflineBorder();
            offlineBorderTimer = setInterval(updateOfflineBorder, 5000);
        }

        function clearOfflineBorder() {
            offlineStart = null;
            clearInterval(offlineBorderTimer);
            offlineBorderTimer = null;
            const border = document.getElementById('offlineBorder');
            border.className = 'offline-border';
            border.style.borderColor = '';
            border.style.animation = '';
            border.style.backgroundImage = '';
            border.style.boxShadow = '';
            const dbg = document.getElementById('offlineDebug');
            dbg.classList.remove('visible');
        }

        // ─── Keyboard Lockdown ───
        document.addEventListener('keydown', (e) => {
            // Ctrl+Alt+Shift+O → system config
            if (e.ctrlKey && e.altKey && e.shiftKey && e.key === 'O') {
                window.location.href = '/system_options.html';
                return;
            }
            // Ctrl+Alt+Shift+B → debug: cycle template + toggle time accel
            if (e.ctrlKey && e.altKey && e.shiftKey && e.key === 'B') {
                e.preventDefault();
                debugMode = true;
                activeTemplateIndex = (activeTemplateIndex + 1) % OFFLINE_TEMPLATES.length;
                debugTimeMultiplier = 60;  // 60× = 1 hour per minute
                applyTemplate(activeTemplateIndex);
                if (!offlineStart) offlineStart = Date.now();
                updateOfflineBorder();
                return;
            }
            e.preventDefault();
            e.stopPropagation();
        }, true);

        document.addEventListener('contextmenu', e => e.preventDefault());

        // ─── Device Info Polling ───
        function updateDeviceInfo() {
            fetch('/api/status')
                .then(r => r.json())
                .then(data => {
                    const el = id => document.getElementById(id);
                    if (el('infoHostname')) el('infoHostname').textContent = data.hostname || data.three_word_name || '--';
                    if (el('infoIp')) el('infoIp').textContent = data.ip_address || data.ethernet?.ip || data.wifi?.ip || '--';

                    const netEl = el('infoNetwork');
                    if (netEl) {
                        if (data.ethernet_connected) {
                            netEl.textContent = 'Ethernet';
                            netEl.className = 'info-value connected';
                        } else if (data.wifi_connected) {
                            netEl.textContent = data.ssid ? 'WiFi (' + data.ssid + ')' : 'WiFi';
                            netEl.className = 'info-value connected';
                        } else {
                            netEl.textContent = 'Disconnected';
                            netEl.className = 'info-value disconnected';
                        }
                    }
                })
                .catch(() => { });
        }

        // ─── Init ───
        async function init() {
            document.body.classList.add('ready', 'locked');
            setStatus('syncing', 'connecting');
            applyTemplate(0);  // Default template
            connectWebSocket();
            updateDeviceInfo();
            setInterval(updateDeviceInfo, 30000);  // Refresh device info every 30s

            // Show waiting state with transition
            const ws = document.getElementById('waitingState');
            requestAnimationFrame(() => ws.classList.add('ready'));

            // Wait a moment for WS registration, then fetch config
            setTimeout(async () => {
                await fetchConfig();
            }, 2000);
        }

        init();
    </script>
</body>

</html>