<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>ODS Player</title>
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@700&display=swap"
        rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap"
        rel="stylesheet" />
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            background: #000 !important;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Inter', -apple-system, sans-serif;
        }

        body {
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        body.ready {
            opacity: 1;
        }

        /* ─── Content Display ─── */
        .player-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slide.active {
            opacity: 1;
            z-index: 2;
        }

        .slide.outgoing {
            opacity: 0;
            z-index: 1;
        }

        .slide img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        .slide video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        /* ─── Waiting for Content State ─── */
        .waiting-state {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: url('/resources/designs/ODS_Background.png') center/cover no-repeat;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .waiting-state.hidden {
            display: none;
        }

        .waiting-card {
            background: rgba(255, 255, 255, 0.08) !important;
            backdrop-filter: blur(40px) !important;
            -webkit-backdrop-filter: blur(40px) !important;
            border: 1px solid rgba(255, 255, 255, 0.15) !important;
            border-radius: 24px !important;
            padding: 60px 48px !important;
            text-align: center;
            max-width: 520px;
            width: 90%;
        }

        .waiting-icon {
            font-size: 64px;
            color: rgba(255, 255, 255, 0.4);
            margin-bottom: 24px;
        }

        .waiting-title {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 8px;
            letter-spacing: -0.01em;
        }

        .waiting-subtitle {
            font-size: 15px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.5;
            margin-bottom: 32px;
        }

        .waiting-pulse {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            border-radius: 100px;
            background: rgba(59, 130, 246, 0.12);
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .waiting-pulse .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #3b82f6;
            animation: pulse-dot 2s ease-in-out infinite;
        }

        .waiting-pulse span {
            font-size: 13px;
            font-weight: 500;
            color: rgba(59, 130, 246, 0.8);
            letter-spacing: 0.02em;
        }

        @keyframes pulse-dot {

            0%,
            100% {
                opacity: 0.3;
                transform: scale(0.8);
            }

            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        /* ─── Status Pill (bottom-right, minimal) ─── */
        .status-pill {
            position: fixed;
            bottom: 16px;
            right: 16px;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 100px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            z-index: 100;
            opacity: 0.6;
            transition: opacity 0.3s ease;
        }

        .status-pill:hover {
            opacity: 1;
        }

        .status-pill .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #10b981;
        }

        .status-pill .dot.offline {
            background: #ef4444;
        }

        .status-pill .dot.syncing {
            background: #f59e0b;
            animation: pulse-dot 1.5s ease-in-out infinite;
        }

        .status-pill .label {
            font-size: 11px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'JetBrains Mono', monospace;
        }

        /* ─── Progress Bar (thin, top edge) ─── */
        .slide-progress {
            position: fixed;
            top: 0;
            left: 0;
            height: 3px;
            background: rgba(59, 130, 246, 0.7);
            z-index: 50;
            transition: width linear;
            border-radius: 0 2px 2px 0;
        }

        /* ─── Keyboard lockdown ─── */
        body.locked * {
            user-select: none !important;
        }

        /* ─── Offline Border Overlay ─── */
        .offline-border {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 99;
            box-sizing: border-box;
            border: 0px solid transparent;
            transition: border-color 0.6s ease;
            will-change: border-color, border-width, box-shadow, background-position;
        }

        .offline-border.active {
            border-width: 3px;
        }

        /* ─── Stage 4: Marching Ants (Templates 0, 4) ─── */
        .offline-border.anim-ants {
            border: 3px solid transparent;
            background-image:
                linear-gradient(90deg, var(--ob-stage4) 50%, transparent 50%),
                linear-gradient(90deg, var(--ob-stage4) 50%, transparent 50%),
                linear-gradient(0deg, var(--ob-stage4) 50%, transparent 50%),
                linear-gradient(0deg, var(--ob-stage4) 50%, transparent 50%);
            background-repeat: repeat-x, repeat-x, repeat-y, repeat-y;
            background-size: 20px 3px, 20px 3px, 3px 20px, 3px 20px;
            background-position: 0 0, 100% 100%, 0 100%, 100% 0;
            animation: marching-ants 1s linear infinite;
        }

        @keyframes marching-ants {
            0% {
                background-position: 0 0, 100% 100%, 0 100%, 100% 0;
            }

            100% {
                background-position: 20px 0, -20px 100%, 0 -20px, 100% 20px;
            }
        }

        /* ─── Stage 4: Breathing Glow (Template 2) ─── */
        .offline-border.anim-glow {
            border: 3px solid var(--ob-stage4);
            animation: breathing-glow 2s ease-in-out infinite;
        }

        @keyframes breathing-glow {

            0%,
            100% {
                box-shadow: inset 0 0 10px var(--ob-stage4-glow), 0 0 10px var(--ob-stage4-glow);
            }

            50% {
                box-shadow: inset 0 0 25px var(--ob-stage4-glow), 0 0 35px var(--ob-stage4-glow);
            }
        }

        /* ─── Stage 4: Heartbeat Pulse (Template 5) ─── */
        .offline-border.anim-heartbeat {
            border-color: var(--ob-stage4);
            animation: heartbeat 1.5s ease-in-out infinite;
        }

        @keyframes heartbeat {

            0%,
            100% {
                border-width: 3px;
            }

            50% {
                border-width: 6px;
            }
        }

        /* ─── Stage 4: Conic Gradient Rotation (Template 3) ─── */
        .offline-border.anim-conic {
            border: 3px solid transparent;
            border-image: conic-gradient(var(--ob-stage4), var(--ob-stage3), var(--ob-stage4)) 1;
            animation: conic-rotation 2s linear infinite;
        }

        @keyframes conic-rotation {
            0% {
                filter: hue-rotate(0deg);
            }

            100% {
                filter: hue-rotate(360deg);
            }
        }

        /* ─── Stage 4: Synchronous Blink (Template 1) ─── */
        .offline-border.anim-blink {
            animation: sync-blink 2s steps(1) infinite;
        }

        @keyframes sync-blink {

            0%,
            49.9% {
                border-color: #000000;
            }

            50%,
            100% {
                border-color: #ffffff;
            }
        }

        /* ─── Debug Overlay ─── */
        .offline-debug {
            position: fixed;
            top: 8px;
            left: 8px;
            padding: 6px 12px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            z-index: 200;
            pointer-events: none;
            display: none;
        }

        .offline-debug.visible {
            display: block;
        }
    </style>
</head>

<body>
    <!-- Content Canvas -->
    <div class="player-canvas" id="playerCanvas"></div>

    <!-- Waiting for Content -->
    <div class="waiting-state" id="waitingState">
        <div class="waiting-card">
            <div class="waiting-icon">
                <span class="material-symbols-outlined" style="font-size: 64px;">tv_signin</span>
            </div>
            <div class="waiting-title">Paired & Ready</div>
            <div class="waiting-subtitle">
                This display is paired with ODS Cloud.<br>
                Assign a playlist from the dashboard to begin.
            </div>
            <div class="waiting-pulse">
                <div class="dot"></div>
                <span>Awaiting content</span>
            </div>
        </div>
    </div>

    <!-- Slide Progress Bar -->
    <div class="slide-progress" id="slideProgress"></div>

    <!-- Offline Border Overlay -->
    <div class="offline-border" id="offlineBorder"></div>

    <!-- Debug Overlay -->
    <div class="offline-debug" id="offlineDebug"></div>

    <!-- Status Pill -->
    <div class="status-pill" id="statusPill">
        <div class="dot" id="statusDot"></div>
        <div class="label" id="statusLabel">connecting</div>
    </div>

    <script>
        // ========================================
        // ODS PLAYER — Content Renderer
        // ========================================
        const API_URL = 'https://api.ods-cloud.com';
        const CONFIG_POLL_INTERVAL = 30 * 1000;     // Check for config changes every 30s
        const HEARTBEAT_INTERVAL = 60 * 1000;       // Heartbeat every 60s
        const RECONNECT_DELAY = 5000;

        let playerId = localStorage.getItem('ods_player_id');
        let deviceUuid = localStorage.getItem('ods_device_uuid');
        let cpuSerial = localStorage.getItem('ods_cpu_serial');
        let socket = null;
        let currentConfig = null;
        let currentConfigHash = null;
        let slideTimer = null;
        let progressTimer = null;
        let currentSlideIndex = 0;
        let assets = [];

        // ─── Status Updates ───
        function setStatus(state, label) {
            const dot = document.getElementById('statusDot');
            const lbl = document.getElementById('statusLabel');
            dot.className = 'dot' + (state === 'offline' ? ' offline' : state === 'syncing' ? ' syncing' : '');
            lbl.textContent = label || state;
        }

        // ─── Redirect if not paired ───
        if (!playerId && !deviceUuid) {
            window.location.href = '/player_link.html';
        }

        // ─── WebSocket Connection ───
        function connectWebSocket() {
            socket = io(API_URL, {
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionDelay: RECONNECT_DELAY,
                reconnectionAttempts: Infinity
            });

            socket.on('connect', () => {
                console.log('[WS] Connected');
                setStatus('online', 'connected');
                clearOfflineBorder();

                // Register this player
                socket.emit('register', {
                    cpu_serial: cpuSerial,
                    name: localStorage.getItem('ods_device_name') || 'ODS Player',
                    device_uuid: deviceUuid
                });
            });

            socket.on('registered', (player) => {
                console.log('[WS] Registered:', player.id);
                if (!playerId) {
                    playerId = player.id;
                    localStorage.setItem('ods_player_id', playerId);
                }
            });

            // Real-time playlist deployment
            socket.on('deploy_playlist', async (data) => {
                console.log('[WS] Playlist deployed:', data);
                setStatus('syncing', 'syncing');
                await fetchConfig();
            });

            // Pairing success — reload config
            socket.on('pairing:success', async (data) => {
                if (data.device_uuid === deviceUuid) {
                    console.log('[WS] Pairing confirmed');
                    await fetchConfig();
                }
            });

            socket.on('disconnect', () => {
                console.log('[WS] Disconnected');
                setStatus('offline', 'offline');
                startOfflineBorder();
            });

            socket.on('connect_error', (err) => {
                console.error('[WS] Connection error:', err.message);
                setStatus('offline', 'reconnecting');
                startOfflineBorder();
            });
        }

        // ─── Heartbeat ───
        setInterval(() => {
            if (socket?.connected) {
                socket.emit('heartbeat', { player_id: playerId });
            }
        }, HEARTBEAT_INTERVAL);

        // ─── Config Fetch ───
        async function fetchConfig() {
            try {
                if (!deviceUuid) return;

                // First: lightweight hash check
                if (currentConfigHash) {
                    try {
                        const hashResp = await fetch(`${API_URL}/api/device/config/hash/${deviceUuid}`);
                        if (hashResp.ok) {
                            const hashData = await hashResp.json();
                            if (hashData.config_hash === currentConfigHash) {
                                console.log('[Config] No changes');
                                return; // Config unchanged
                            }
                        }
                    } catch (e) {
                        console.warn('[Config] Hash check failed, fetching full config');
                    }
                }

                // Full config fetch
                const resp = await fetch(`${API_URL}/api/device/config/${deviceUuid}`);
                if (!resp.ok) {
                    if (resp.status === 403) {
                        console.log('[Config] Device not paired yet');
                        showWaiting();
                        return;
                    }
                    console.error('[Config] Fetch failed:', resp.status);
                    return;
                }

                const config = await resp.json();
                currentConfig = config;
                currentConfigHash = config.config_hash;

                // Store player_id from config for WebSocket
                if (config.player_id && !playerId) {
                    playerId = config.player_id;
                    localStorage.setItem('ods_player_id', playerId);
                }

                console.log('[Config] Loaded:', {
                    playlist: config.playlist?.name,
                    assets: config.playlist?.assets?.length || 0
                });

                if (config.playlist && config.playlist.assets?.length > 0) {
                    await loadPlaylist(config.playlist);
                } else {
                    showWaiting();
                }

                setStatus('online', 'connected');

                // Apply offline border template from org config
                if (config.offline_border) {
                    const tpl = config.offline_border.template;
                    if (typeof tpl === 'number' && tpl >= 0 && tpl < OFFLINE_TEMPLATES.length) {
                        applyTemplate(tpl);
                    }
                    // Future: custom_colors override
                    if (config.offline_border.custom_colors && config.offline_border.custom_colors.length === 4) {
                        const cc = config.offline_border.custom_colors;
                        const root = document.documentElement.style;
                        root.setProperty('--ob-stage1', cc[0]);
                        root.setProperty('--ob-stage2', cc[1]);
                        root.setProperty('--ob-stage3', cc[2]);
                        root.setProperty('--ob-stage4', cc[3]);
                    }
                }

                // Report sync status
                if (socket?.connected) {
                    socket.emit('sync_status', {
                        status: 'synced',
                        config_hash: currentConfigHash,
                        downloaded: config.playlist?.assets?.length || 0
                    });
                }

            } catch (error) {
                console.error('[Config] Error:', error);
                setStatus('offline', 'error');
            }
        }

        // ─── Playlist Rendering ───
        function showWaiting() {
            document.getElementById('waitingState').classList.remove('hidden');
            document.getElementById('playerCanvas').innerHTML = '';
            document.getElementById('slideProgress').style.width = '0';
            clearTimeout(slideTimer);
            clearInterval(progressTimer);
            assets = [];
            currentSlideIndex = 0;
        }

        async function loadPlaylist(playlist) {
            // Hide waiting state
            document.getElementById('waitingState').classList.add('hidden');

            assets = playlist.assets.sort((a, b) => a.order - b.order);
            currentSlideIndex = 0;

            if (assets.length === 0) {
                showWaiting();
                return;
            }

            // Pre-create slide elements
            const canvas = document.getElementById('playerCanvas');
            canvas.innerHTML = '';

            assets.forEach((asset, i) => {
                const slide = document.createElement('div');
                slide.className = 'slide' + (i === 0 ? ' active' : '');
                slide.id = `slide-${i}`;

                if (asset.type === 'video') {
                    const video = document.createElement('video');
                    video.src = `${API_URL}${asset.url}`;
                    video.autoplay = (i === 0);
                    video.muted = true;
                    video.loop = false;
                    video.playsInline = true;
                    video.preload = 'auto';
                    video.addEventListener('ended', () => nextSlide());
                    video.addEventListener('error', (e) => {
                        console.error(`[Video] Error loading asset ${asset.id}:`, e);
                        nextSlide();
                    });
                    slide.appendChild(video);
                } else {
                    // Image (default)
                    const img = document.createElement('img');
                    img.src = `${API_URL}${asset.url}`;
                    img.alt = asset.filename || '';
                    img.loading = (i < 2) ? 'eager' : 'lazy';
                    img.addEventListener('error', (e) => {
                        console.error(`[Image] Error loading asset ${asset.id}:`, e);
                    });
                    slide.appendChild(img);
                }

                canvas.appendChild(slide);
            });

            // Start slideshow
            startSlideTimer();
        }

        function startSlideTimer() {
            clearTimeout(slideTimer);
            clearInterval(progressTimer);

            const asset = assets[currentSlideIndex];
            if (!asset) return;

            const slide = document.getElementById(`slide-${currentSlideIndex}`);
            const video = slide?.querySelector('video');

            // For videos, let the 'ended' event handle transition
            if (asset.type === 'video' && video) {
                video.currentTime = 0;
                video.play().catch(e => console.warn('[Video] Autoplay blocked:', e));
                // Progress bar for video
                const updateVideoProgress = () => {
                    if (video.duration) {
                        const pct = (video.currentTime / video.duration) * 100;
                        document.getElementById('slideProgress').style.width = `${pct}%`;
                    }
                    if (!video.ended) requestAnimationFrame(updateVideoProgress);
                };
                requestAnimationFrame(updateVideoProgress);
                return;
            }

            // For images, use duration timer
            const duration = (asset.duration || 10) * 1000;
            const progressBar = document.getElementById('slideProgress');
            progressBar.style.transition = 'none';
            progressBar.style.width = '0%';

            // Trigger reflow then animate
            requestAnimationFrame(() => {
                progressBar.style.transition = `width ${duration}ms linear`;
                progressBar.style.width = '100%';
            });

            slideTimer = setTimeout(() => nextSlide(), duration);
        }

        function nextSlide() {
            const prevIndex = currentSlideIndex;
            currentSlideIndex = (currentSlideIndex + 1) % assets.length;

            // Pause previous video
            const prevSlide = document.getElementById(`slide-${prevIndex}`);
            const prevVideo = prevSlide?.querySelector('video');
            if (prevVideo) prevVideo.pause();

            // Transition
            prevSlide?.classList.remove('active');
            prevSlide?.classList.add('outgoing');

            const nextSlideEl = document.getElementById(`slide-${currentSlideIndex}`);
            nextSlideEl?.classList.add('active');

            // Clean outgoing after transition
            setTimeout(() => {
                prevSlide?.classList.remove('outgoing');
            }, 1200);

            startSlideTimer();
        }

        // ─── Config Polling ───
        setInterval(() => fetchConfig(), CONFIG_POLL_INTERVAL);

        // ========================================
        // OFFLINE BORDER SYSTEM
        // ========================================

        const OFFLINE_TEMPLATES = [
            {
                name: 'Standard Logic',
                stages: ['#FFFF00', '#FFA500', '#FF0000', '#FF0000'],
                animation: 'ants'
            },
            {
                name: 'Minimal & Neutral',
                stages: ['#F2D2BD', '#CC7722', '#361010', '#000000'],
                animation: 'blink'
            },
            {
                name: 'Tokyo Night',
                stages: ['#24283b', '#e0af68', '#f7768e', '#f7768e'],
                animation: 'glow',
                glowColor: 'rgba(247, 118, 142, 0.8)'
            },
            {
                name: 'Catppuccin',
                stages: ['#f5e0dc', '#fab387', '#eba0ac', '#eba0ac'],
                animation: 'conic'
            },
            {
                name: 'Monokai Pro',
                stages: ['#a9dc76', '#fc9867', '#ff6188', '#ff6188'],
                animation: 'ants'
            },
            {
                name: 'Natural & Calm',
                stages: ['#87a980', '#d2b48c', '#e2725b', '#e2725b'],
                animation: 'heartbeat'
            }
        ];

        let offlineStart = null;
        let offlineBorderTimer = null;
        let activeTemplateIndex = 0;
        let debugMode = false;
        let debugTimeMultiplier = 1;  // 1 = real-time, 60 = 1min per second

        function applyTemplate(index) {
            const t = OFFLINE_TEMPLATES[index];
            if (!t) return;
            activeTemplateIndex = index;
            const root = document.documentElement.style;
            root.setProperty('--ob-stage1', t.stages[0]);
            root.setProperty('--ob-stage2', t.stages[1]);
            root.setProperty('--ob-stage3', t.stages[2]);
            root.setProperty('--ob-stage4', t.stages[3]);
            root.setProperty('--ob-stage4-glow', t.glowColor || t.stages[3]);
        }

        function getOfflineMinutes() {
            if (!offlineStart) return 0;
            return ((Date.now() - offlineStart) / 60000) * debugTimeMultiplier;
        }

        function getStage(minutes) {
            if (minutes < 30) return 1;
            if (minutes < 60) return 2;
            if (minutes < 120) return 3;
            return 4;
        }

        function updateOfflineBorder() {
            if (!offlineStart) return;
            const minutes = getOfflineMinutes();
            const stage = getStage(minutes);
            const t = OFFLINE_TEMPLATES[activeTemplateIndex];
            const border = document.getElementById('offlineBorder');

            // Clear all animation classes
            border.classList.remove('anim-ants', 'anim-glow', 'anim-heartbeat', 'anim-conic', 'anim-blink');

            if (stage < 4) {
                // Stages 1-3: solid color
                border.className = 'offline-border active';
                border.style.borderColor = t.stages[stage - 1];
                border.style.animation = '';
                border.style.backgroundImage = '';
                border.style.boxShadow = '';
            } else {
                // Stage 4: animated
                border.className = 'offline-border active anim-' + t.animation;
                border.style.borderColor = '';
            }

            // Debug overlay
            if (debugMode) {
                const dbg = document.getElementById('offlineDebug');
                dbg.classList.add('visible');
                dbg.textContent = `T${activeTemplateIndex}: ${t.name} | Stage ${stage} | ${Math.floor(minutes)}m offline | ${debugTimeMultiplier}×`;
            }
        }

        function startOfflineBorder() {
            if (offlineStart) return;  // Already tracking
            offlineStart = Date.now();
            applyTemplate(activeTemplateIndex);
            updateOfflineBorder();
            offlineBorderTimer = setInterval(updateOfflineBorder, 5000);
        }

        function clearOfflineBorder() {
            offlineStart = null;
            clearInterval(offlineBorderTimer);
            offlineBorderTimer = null;
            const border = document.getElementById('offlineBorder');
            border.className = 'offline-border';
            border.style.borderColor = '';
            border.style.animation = '';
            border.style.backgroundImage = '';
            border.style.boxShadow = '';
            const dbg = document.getElementById('offlineDebug');
            dbg.classList.remove('visible');
        }

        // ─── Keyboard Lockdown ───
        document.addEventListener('keydown', (e) => {
            // Ctrl+Alt+Shift+O → system config
            if (e.ctrlKey && e.altKey && e.shiftKey && e.key === 'O') {
                window.location.href = '/system_config.html';
                return;
            }
            // Ctrl+Alt+Shift+B → debug: cycle template + toggle time accel
            if (e.ctrlKey && e.altKey && e.shiftKey && e.key === 'B') {
                e.preventDefault();
                debugMode = true;
                activeTemplateIndex = (activeTemplateIndex + 1) % OFFLINE_TEMPLATES.length;
                debugTimeMultiplier = 60;  // 60× = 1 hour per minute
                applyTemplate(activeTemplateIndex);
                if (!offlineStart) offlineStart = Date.now();
                updateOfflineBorder();
                return;
            }
            e.preventDefault();
            e.stopPropagation();
        }, true);

        document.addEventListener('contextmenu', e => e.preventDefault());

        // ─── Init ───
        async function init() {
            document.body.classList.add('ready', 'locked');
            setStatus('syncing', 'connecting');
            applyTemplate(0);  // Default template
            connectWebSocket();

            // Wait a moment for WS registration, then fetch config
            setTimeout(async () => {
                await fetchConfig();
            }, 2000);
        }

        init();
    </script>
</body>

</html>